<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰“é£æœºæ¸¸æˆ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #001122, #003366);
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(to bottom, #000011, #001133);
            cursor: crosshair;
        }

        #gameUI {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            z-index: 100;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 200;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            opacity: 0.8;
        }

        .btn {
            background: #0066cc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
        }

        .btn:hover {
            background: #0052a3;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="gameUI">
            <div>å¾—åˆ†: <span id="score">0</span></div>
            <div>ç”Ÿå‘½: <span id="lives">3</span></div>
            <div>ç­‰çº§: <span id="level">1</span></div>
        </div>

        <div id="instructions">
            <div>ğŸ® æ“ä½œè¯´æ˜:</div>
            <div>é¼ æ ‡ç§»åŠ¨ - æ§åˆ¶é£æœº</div>
            <div>ç‚¹å‡»é¼ æ ‡ - å‘å°„å­å¼¹</div>
            <div>ç©ºæ ¼é”® - æš‚åœ/ç»§ç»­</div>
        </div>

        <div id="gameOver">
            <h2>æ¸¸æˆç»“æŸ!</h2>
            <p>æœ€ç»ˆå¾—åˆ†: <span id="finalScore">0</span></p>
            <button class="btn" onclick="restartGame()">é‡æ–°å¼€å§‹</button>
        </div>
    </div>

    <script>
        // æ¸¸æˆçŠ¶æ€
        const gameState = {
            score: 0,
            lives: 3,
            level: 1,
            isPaused: false,
            isGameOver: false
        };

        // è·å–ç”»å¸ƒå’Œä¸Šä¸‹æ–‡
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // è®¾ç½®ç”»å¸ƒå¤§å°
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ç©å®¶é£æœº
        class Player {
            constructor() {
                this.width = 60;
                this.height = 80;
                this.x = canvas.width / 2 - this.width / 2;
                this.y = canvas.height - this.height - 50;
                this.speed = 8;
                this.bullets = [];
                this.lastShot = 0;
                this.shotCooldown = 150; // æ¯«ç§’
            }

            update(mouseX) {
                // å¹³æ»‘è·Ÿéšé¼ æ ‡
                const targetX = mouseX - this.width / 2;
                this.x += (targetX - this.x) * 0.1;

                // é™åˆ¶åœ¨ç”»å¸ƒå†…
                this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));

                // æ›´æ–°å­å¼¹
                this.bullets = this.bullets.filter(bullet => {
                    bullet.y -= bullet.speed;
                    return bullet.y > -10;
                });
            }

            shoot() {
                const now = Date.now();
                if (now - this.lastShot > this.shotCooldown) {
                    this.bullets.push({
                        x: this.x + this.width / 2 - 2,
                        y: this.y,
                        width: 4,
                        height: 20,
                        speed: 12
                    });
                    this.lastShot = now;
                }
            }

            draw() {
                // ç»˜åˆ¶é£æœºä¸»ä½“
                ctx.fillStyle = '#00ff88';
                ctx.fillRect(this.x + 20, this.y + 20, 20, 40);

                // ç»˜åˆ¶æœºç¿¼
                ctx.fillStyle = '#00cc66';
                ctx.fillRect(this.x + 5, this.y + 30, 50, 15);

                // ç»˜åˆ¶æœºå¤´
                ctx.fillStyle = '#00ffaa';
                ctx.beginPath();
                ctx.moveTo(this.x + 30, this.y);
                ctx.lineTo(this.x + 20, this.y + 20);
                ctx.lineTo(this.x + 40, this.y + 20);
                ctx.closePath();
                ctx.fill();

                // ç»˜åˆ¶å­å¼¹
                ctx.fillStyle = '#ffff00';
                this.bullets.forEach(bullet => {
                    ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                    // å­å¼¹å…‰æ™•
                    ctx.shadowColor = '#ffff00';
                    ctx.shadowBlur = 10;
                    ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                    ctx.shadowBlur = 0;
                });
            }
        }

        // æ•Œæœºç±»
        class Enemy {
            constructor() {
                this.width = 50;
                this.height = 50;
                this.x = Math.random() * (canvas.width - this.width);
                this.y = -this.height;
                this.speed = 2 + Math.random() * 3 + gameState.level * 0.5;
                this.type = Math.random() > 0.7 ? 'fast' : 'normal';
                if (this.type === 'fast') {
                    this.speed *= 1.5;
                    this.color = '#ff4444';
                } else {
                    this.color = '#ff6666';
                }
            }

            update() {
                this.y += this.speed;
            }

            draw() {
                // ç»˜åˆ¶æ•Œæœº
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x + 15, this.y, 20, 30);

                // æ•Œæœºç¿¼
                ctx.fillStyle = '#cc4444';
                ctx.fillRect(this.x, this.y + 10, 50, 10);

                // æ•Œæœºå°¾ç¿¼
                ctx.fillStyle = '#aa4444';
                ctx.fillRect(this.x + 10, this.y + 30, 30, 15);
            }

            isOffScreen() {
                return this.y > canvas.height;
            }
        }

        // çˆ†ç‚¸æ•ˆæœç±»
        class Explosion {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.particles = [];
                this.life = 30;

                // åˆ›å»ºç²’å­
                for (let i = 0; i < 15; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 30
                    });
                }
            }

            update() {
                this.life--;
                this.particles.forEach(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life--;
                    particle.vx *= 0.98;
                    particle.vy *= 0.98;
                });
            }

            draw() {
                this.particles.forEach(particle => {
                    if (particle.life > 0) {
                        ctx.fillStyle = `rgba(255, ${100 + particle.life * 5}, 0, ${particle.life / 30})`;
                        ctx.fillRect(particle.x, particle.y, 3, 3);
                    }
                });
            }

            isDead() {
                return this.life <= 0;
            }
        }

        // æ¸¸æˆå¯¹è±¡
        const player = new Player();
        const enemies = [];
        const explosions = [];
        let stars = [];

        // åˆå§‹åŒ–æ˜Ÿç©ºèƒŒæ™¯
        function initStars() {
            for (let i = 0; i < 100; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2,
                    speed: 0.5 + Math.random() * 1.5
                });
            }
        }
        initStars();

        // é¼ æ ‡æ§åˆ¶
        let mouseX = canvas.width / 2;
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
        });

        canvas.addEventListener('click', () => {
            if (!gameState.isPaused && !gameState.isGameOver) {
                player.shoot();
            }
        });

        // é”®ç›˜æ§åˆ¶
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                togglePause();
            }
        });

        // æš‚åœåŠŸèƒ½
        function togglePause() {
            gameState.isPaused = !gameState.isPaused;
        }

        // ç¢°æ’æ£€æµ‹
        function checkCollisions() {
            // æ£€æŸ¥å­å¼¹å‡»ä¸­æ•Œæœº
            player.bullets.forEach((bullet, bulletIndex) => {
                enemies.forEach((enemy, enemyIndex) => {
                    if (bullet.x < enemy.x + enemy.width &&
                        bullet.x + bullet.width > enemy.x &&
                        bullet.y < enemy.y + enemy.height &&
                        bullet.y + bullet.height > enemy.y) {

                        // å‡»ä¸­æ•Œæœº
                        explosions.push(new Explosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2));
                        player.bullets.splice(bulletIndex, 1);
                        enemies.splice(enemyIndex, 1);
                        gameState.score += enemy.type === 'fast' ? 20 : 10;
                        updateUI();
                    }
                });
            });

            // æ£€æŸ¥æ•Œæœºæ’å‡»ç©å®¶
            enemies.forEach((enemy, enemyIndex) => {
                if (enemy.x < player.x + player.width &&
                    enemy.x + enemy.width > player.x &&
                    enemy.y < player.y + player.height &&
                    enemy.y + enemy.height > player.y) {

                    // æ’å‡»ç©å®¶
                    explosions.push(new Explosion(player.x + player.width/2, player.y + player.height/2));
                    enemies.splice(enemyIndex, 1);
                    gameState.lives--;
                    updateUI();

                    if (gameState.lives <= 0) {
                        gameOver();
                    }
                }
            });
        }

        // æ›´æ–°UI
        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('level').textContent = gameState.level;

            // å‡çº§é€»è¾‘
            if (gameState.score > gameState.level * 200) {
                gameState.level++;
            }
        }

        // æ¸¸æˆç»“æŸ
        function gameOver() {
            gameState.isGameOver = true;
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('gameOver').style.display = 'block';
        }

        // é‡æ–°å¼€å§‹æ¸¸æˆ
        function restartGame() {
            gameState.score = 0;
            gameState.lives = 3;
            gameState.level = 1;
            gameState.isPaused = false;
            gameState.isGameOver = false;

            player.bullets = [];
            enemies.length = 0;
            explosions.length = 0;

            document.getElementById('gameOver').style.display = 'none';
            updateUI();
        }

        // æ¸¸æˆä¸»å¾ªç¯
        function gameLoop() {
            if (!gameState.isPaused && !gameState.isGameOver) {
                // æ¸…ç©ºç”»å¸ƒ
                ctx.fillStyle = 'rgba(0, 0, 17, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // æ›´æ–°å’Œç»˜åˆ¶æ˜Ÿç©ºèƒŒæ™¯
                stars.forEach(star => {
                    star.y += star.speed;
                    if (star.y > canvas.height) {
                        star.y = 0;
                        star.x = Math.random() * canvas.width;
                    }

                    ctx.fillStyle = `rgba(255, 255, 255, ${star.size / 2})`;
                    ctx.fillRect(star.x, star.y, star.size, star.size);
                });

                // æ›´æ–°ç©å®¶
                player.update(mouseX);
                player.draw();

                // ç”Ÿæˆæ•Œæœº
                if (Math.random() < 0.02 + gameState.level * 0.005) {
                    enemies.push(new Enemy());
                }

                // æ›´æ–°å’Œç»˜åˆ¶æ•Œæœº
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    enemy.update();

                    if (enemy.isOffScreen()) {
                        enemies.splice(i, 1);
                        continue;
                    }

                    enemy.draw();
                }

                // æ›´æ–°å’Œç»˜åˆ¶çˆ†ç‚¸æ•ˆæœ
                for (let i = explosions.length - 1; i >= 0; i--) {
                    const explosion = explosions[i];
                    explosion.update();
                    explosion.draw();

                    if (explosion.isDead()) {
                        explosions.splice(i, 1);
                    }
                }

                // ç¢°æ’æ£€æµ‹
                checkCollisions();
            }

            requestAnimationFrame(gameLoop);
        }

        // å¯åŠ¨æ¸¸æˆ
        updateUI();
        gameLoop();

        // ä½¿é‡æ–°å¼€å§‹å‡½æ•°å…¨å±€å¯ç”¨
        window.restartGame = restartGame;
    </script>
</body>
</html>